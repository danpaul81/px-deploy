#!/bin/bash

#
# creates a mongodb deployment on PDS and a pxbbq instance accessing it
# 
# will also create a /px-deploy/script-delete/pds-pxbbq.sh script to remove everything being created by this script
# this will be used by px-deploy to delete PDS Deployments/Targets prior to deleting the px-deploy instance
#
# currently tested only on terraform based aws ec2 instances 
# 
# TODO: React on disabled Versions (14.4)
#
# when running standalone ensure the following variables are set properly
# and  /assets/pds-pxbbq/pds-pxbbq.tpl exists & is accessible
#

PDS_EMAIL=""
PDS_PASSWORD=""
name="dpaul-pds"
cluster=1
# platform="ocp4"
PDS_ENDPOINT="https://gold.pds.portworx.com"
PDS_NAMESPACE="pds-pxbbq"
PDS_DATASERVICE="mdb"
PDS_DATASERVICE_VERSION="7.0.11"

# PDS_APP_CONFIG_TEMPLATE="Default"
# PDS_APP_RESOURCE_TEMPLATE="Tiny"
# PDS_APP_STORAGE_TEMPLATE="Volume%20replication%20(best-effort%20spread)"
# PDS_PROJECT="Default"
#

kubectl create ns $PDS_NAMESPACE
kubectl label ns $PDS_NAMESPACE platform.portworx.com/pds=true

TGT_NAME="px-deploy-$name-$cluster"

[[ -z $PDS_EMAIL ]] && { echo "Error: env variable PDS_USER not set. check your ~/.px-deploy/defaults.yml"; exit 1; }
[[ -z $PDS_PASSWORD ]] && { echo "Error: env variable PDS_PASSWORD not set. check your ~/.px-deploy/defaults.yml"; exit 1; }

echo "retrieving access & refresh token"
OUTPUT=$(curl -s -X "POST" "$PDS_ENDPOINT/core/v1/oauth:login" -H "accept: application/json" -H "Content-Type: application/json" -d '{ 
"email": "'$PDS_EMAIL'", 
"password":"'$PDS_PASSWORD'" 
}')
PDS_TOKEN=$(echo $OUTPUT  | jq -r '.idToken' )
[[ $PDS_TOKEN == "null" ]] && { echo "Error: getting access token."; echo $OUTPUT; exit 1; }
PDS_REFRESH_TOKEN=$(echo $OUTPUT  | jq -r '.refreshToken' )
[[ $PDS_REFRESH_TOKEN == "null" ]] && { echo "Error: getting refresh token."; echo $OUTPUT; exit 1; }

echo "retrieving account id"
OUTPUT=$(curl -s -X "GET"   "$PDS_ENDPOINT/core/v1/whoami"   -H "accept: application/json"   -H "Authorization: Bearer $PDS_TOKEN")
PDS_ACCOUNT_ID=$(echo $OUTPUT | jq -r '.accounts[0].id')
[[ $PDS_ACCOUNT_ID == "null" ]] && { echo "Error: PDS_ACCOUNT_ID not found"; echo $OUTPUT; exit 1; }
echo "PDS_ACCOUNT_ID=\"$PDS_ACCOUNT_ID\""

echo "retrieving tenant uid"
OUTPUT=$(curl -s -X "GET"   "$PDS_ENDPOINT/core/v1/tenants?accountId=$PDS_ACCOUNT_ID" -H "px-account-id: $PDS_ACCOUNT_ID" -H "Authorization: Bearer $PDS_TOKEN")
PDS_TENANT_UID=$(echo $OUTPUT | jq -r '.tenants[0].meta.uid')
[[ $PDS_TENANT_UID == "null" ]] && { echo "Error: PDS_TENANT_UID not found"; echo $OUTPUT; exit 1; }
echo "PDS_TENANT_UID=\"$PDS_TENANT_UID\""

echo "retrieving registration manifest"
curl -s -X "POST" "$PDS_ENDPOINT/core/v1/tenants/$PDS_TENANT_UID:registrationManifests" -H "px-account-id: $PDS_ACCOUNT_ID"  -H "Authorization: Bearer $PDS_TOKEN" -H "Content-Type: application/json" -d '{"clusterName":"'$TGT_NAME'"'} | jq -r '.manifest' > /tmp/manifest.yml

echo "applying registration manifest"
#kubectl apply -f /tmp/manifest.yml

echo "waiting for targetcluster CR connect"
while ! kubectl wait targetclusters.core.portworx.com/px-platform-agent -n px-system --timeout=300s --for=jsonpath='{.status.phase}'='CONNECTED'; do
  sleep 5
done

echo "waiting for targetcluster CR platform agent"
while ! kubectl wait targetclusters.core.portworx.com/px-platform-agent -n px-system --timeout=300s --for=jsonpath='{.status.platform_agent.phase}'='SUCCEEDED'; do
  sleep 2
done

echo "waiting for targetcluster CR platform agent health"
while ! kubectl wait targetclusters.core.portworx.com/px-platform-agent -n px-system --timeout=300s --for=jsonpath='{.status.platform_agent.health}'='HEALTHY'; do
  sleep 2
done

echo "retrieving target cluster id"
OUTPUT=$(curl -s -X "POST" "$PDS_ENDPOINT/core/v1/clusters:search" -H "accept: application/json" -H "px-account-id: $PDS_ACCOUNT_ID" -H "Authorization: Bearer $PDS_TOKEN" -H "Content-Type: application/json" -d '
{"tenantId":"'$PDS_TENANT_UID'","fieldSelector":{"filters":[{"key":"meta.name","op":"IN","values":["'$TGT_NAME'"]}]},"sort":{"sortBy":"CREATED_AT","sortOrder":"DESC"},"pagination":{"pageNumber":"1","pageSize":"10"}}
')
PDS_CLUSTER_UID=$(echo $OUTPUT  | jq -r '.clusters[0].meta.uid' )
[[ $PDS_CLUSTER_UID == "null" ]] && { echo "Error: pds cluster uid."; echo $OUTPUT; exit 1; }
TOTAL_RECORDS=$(echo $OUTPUT  | jq -r '.pagination.totalRecords' )
[[ $TOTAL_RECORDS != "1" ]] && { echo "Error: more than one cluster uid returned"; echo $OUTPUT; exit 1; }
echo "PDS_CLUSTER_UID=$PDS_CLUSTER_UID"

#echo "installing PDS agent"
#OUTPUT=$(curl -s -X "POST" "$PDS_ENDPOINT/core/v1/clusters/$PDS_CLUSTER_UID/applications" -H "accept: application/json" -H "px-account-id: $PDS_ACCOUNT_ID" -H "Authorization: Bearer $PDS_TOKEN" -H "Content-Type: application/json" -d '{"meta":{"name":"pds"}}')
#PDS_APP_UID=$(echo $OUTPUT  | jq -r '.meta.uid' )
#[[ $PDS_APP_UID == "null" ]] && { echo "Error: pds app uid."; echo $OUTPUT; exit 1; }
#echo "PDS_APP_UID=$PDS_APP_UID"

echo "waiting for targetcluster app pds succeed"
while ! kubectl wait targetclusterapplications.core.portworx.com/pds -n px-system --timeout=300s --for=jsonpath='{.status.phase}'='SUCCEEDED'; do
  sleep 5
done

echo "waiting for targetcluster app pds health"
while ! kubectl wait targetclusterapplications.core.portworx.com/pds -n px-system --timeout=300s --for=jsonpath='{.status.health}'='HEALTHY'; do
  sleep 5
done


echo "retreiving pds template revision uid"
OUTPUT=$(curl -s -X "POST" "$PDS_ENDPOINT/core/v1/templates:search" -H "accept: application/json" -H "px-account-id: $PDS_ACCOUNT_ID" -H "Authorization: Bearer $PDS_TOKEN" -H "Content-Type: application/json"
-d '{"tenantId":"'$PDS_TENANT_UID'","infraResourceSelector":{"infraResourceFilters":[]},"fieldSelector":{"filters":[{"key":"config.kind","op":"IN","values":["pds:resource_settings"]}]},"applicationSelector":{"appli
cationFilters":[]},"sort":{"sortBy":"CREATED_AT","sortOrder":"DESC"},"pagination":{"pageNumber":"1","pageSize":"5"}}')
PDS_RESOURCE_TEMPLATE_REVISION_UID=$(echo $OUTPUT  | jq -r '.templates[0].config.revisionUid' )
[[ $PDS_RESOURCE_TEMPLATE_REVISION_UID == "null" ]] && { echo "Error getting resource template revision uid"; echo $OUTPUT; exit 1; }
echo "PDS_RESOURCE_TEMPLATE_UID=$PDS_RESOURCE_TEMPLATE_REVISION_UID"

echo "creating resource template"
OUTPUT=$(curl -s -X "POST" "$PDS_ENDPOINT/core/v1/tenants/$PDS_TENANT_UID/templates" -H "accept: application/json" -H "px-account-id: $PDS_ACCOUNT_ID" -H "Authorization: Bearer $PDS_TOKEN" -H "Content-Type: application/json" -d '{
"meta":{"name":"'$name'-'$cluster'-small"},"config":{"templateValues":{"name":"'$name'-'$cluster'-small","cpu_request":"1","cpu_limit":"2","memory_request":"100M","memory_limit":"200M","storage_request":"10G"}, "revisionUid":"'$PDS_RESOURCE_TEMPLATE_REVISION_UID'"}}')
PDS_RESOURCE_TEMPLATE_UID=$(echo $OUTPUT  | jq -r '.meta.uid' )
[[ $PDS_RESOURCE_TEMPLATE_UID == "null" ]] && { echo "Error creating resource template"; echo $OUTPUT; exit 1; }
echo "PDS_RESOURCE_TEMPLATE_UID=$PDS_RESOURCE_TEMPLATE_UID"



exit



# create a deletion script which will be run by px-deploy before destroying instance
echo "Creating deletion script /px-deploy/script-delete/pds-petclinic.sh"

cat <<EOF > /px-deploy/script-delete/pds-petclinic.sh
#!/bin/bash
echo "Deleting deployment(s) for this deployment target"

OUTPUT=\$(curl -s -X "GET"   "$PDS_ENDPOINT/projects/$PDS_PROJECT_ID/deployments?deployment_target_id=$PDS_DEPLOYMENT_TARGET_ID"   -H "accept: application/json"   -H "Authorization: Bearer $PDS_TOKEN")

echo "Found following deployment(s):"
echo \$OUTPUT | jq -r '.data[] | .name, .id'

for i in \$(echo \$OUTPUT | jq -r '.data[].id'); do
  echo "removing backup schedule/target for \$i"
  curl -s -X "PUT" "$PDS_ENDPOINT/deployments/\$i" -H "accept: application/json"   -H "Authorization: Bearer $PDS_TOKEN" -H "Content-Type: application/json" -d "{ \"scheduled_backup\": { \"backup_policy_id\": null, \"backup_target_id\": null} }" >/dev/null
  
  echo "deleting existing backups"
  BACKUPS=\$(curl -s -X "GET" "$PDS_ENDPOINT/deployments/\$i/backups" -H "accept: application/json"   -H "Authorization: Bearer $PDS_TOKEN")
  for BAK in \$(echo \$BACKUPS | jq -r '.data[].id'); do
    echo "    deleting backup \$BAK"
    DELSTATUS=\$(curl -s -X "DELETE"   "$PDS_ENDPOINT/backups/\$BAK" -H "accept: application/json"   -H "Authorization: Bearer $PDS_TOKEN" | jq -r '.http_status')
	while [ ! -z "\${DELSTATUS}" ]; do
	  echo "      backup job deletion failed with status \$DELSTATUS. Waiting for dependencies to be deleted. Re-try in 5sec"
      echo "      if this fails, check & delete existing backup jobs manually"
      sleep 5	
	  DELSTATUS=\$(curl -s -X "DELETE"   "$PDS_ENDPOINT/backups/\$BAK" -H "accept: application/json"   -H "Authorization: Bearer $PDS_TOKEN" | jq -r '.http_status')
    done
  done

  echo "deleting deployment \$i"
  DELSTATUS=\$(curl -s -X "DELETE"   "$PDS_ENDPOINT/deployments/\$i"   -H "accept: application/json"   -H "Authorization: Bearer $PDS_TOKEN" | jq -r '.http_status')
  
  while [ ! -z "\${DELSTATUS}" ]; do
    echo "deployment deletion failed with status \$DELSTATUS. Waiting for dependencies to be deleted. Re-try in 5sec"
    echo "if this fails, check & delete existing backup jobs manually"
    sleep 5
	DELSTATUS=\$(curl -s -X "DELETE"   "$PDS_ENDPOINT/deployments/\$i"   -H "accept: application/json"   -H "Authorization: Bearer $PDS_TOKEN" | jq -r '.http_status')
  done

done

echo "Deleting Namespace $PDS_NAMESPACE"
kubectl delete namespace $PDS_NAMESPACE --wait=false

echo "Deleting pds helm deployment"

helm delete pds -n pds-system

echo "Deleting pds-system namespace"

kubectl delete namespace pds-system --wait=false

DEPLOY_STAT=\$(curl -s -X "GET"   "$PDS_ENDPOINT/deployment-targets/$PDS_DEPLOYMENT_TARGET_ID"   -H "accept: application/json"   -H "Authorization: Bearer $PDS_TOKEN"  | jq -r '.status')

[[ \$DEPLOY_STAT == "null" ]] && { echo "Error: Deployment Status empty. ";  exit 1; }

echo "Waiting for Deployment Target to become unhealthy (this can take up to 5min)"

while [ "\$DEPLOY_STAT" != "unhealthy" ]; do
	sleep 5
	echo "Current State	\$DEPLOY_STAT	\$(date)"
	DEPLOY_STAT=\$(curl -s -X "GET"   "$PDS_ENDPOINT/deployment-targets/$PDS_DEPLOYMENT_TARGET_ID"   -H "accept: application/json"   -H "Authorization: Bearer $PDS_TOKEN"  | jq -r '.status')
	[[ \$DEPLOY_STAT == "null" ]] && { echo "Error: Deployment Status empty. ";  exit 1; }
done

echo "Deleting Deployment Target"

curl -s -X "DELETE"   "$PDS_ENDPOINT/deployment-targets/$PDS_DEPLOYMENT_TARGET_ID"   -H "accept: application/json"   -H "Authorization: Bearer $PDS_TOKEN"

EOF

OUTPUT=$(curl -s -X "GET"   "$PDS_ENDPOINT/deployments/$PDS_DEPLOYMENT_ID"   -H "accept: application/json"   -H "Authorization: Bearer $PDS_TOKEN")
PDS_DEPLOYMENT_CLUSTER_RESOURCE_NAME=$(echo $OUTPUT | jq -r '.cluster_resource_name')
[[ $PDS_DEPLOYMENT_CLUSTER_RESOURCE_NAME == "null" ]] && { echo "Error: PDS_DEPLOYMENT_CLUSTER_RESOURCE_NAME not found"; echo $OUTPUT; exit 1; }
echo "PDS_DEPLOYMENT_CLUSTER_RESOURCE_NAME=\"$PDS_DEPLOYMENT_CLUSTER_RESOURCE_NAME\""

PDS_CONNECTION=$(curl -s -X "GET"   "$PDS_ENDPOINT/deployments/$PDS_DEPLOYMENT_ID/connection-info"   -H "accept: application/json"   -H "Authorization: Bearer $PDS_TOKEN")

PDS_VIP=$(echo $PDS_CONNECTION | jq -r '.clusterDetails.host')
[[ $PDS_VIP == "null" ]] && { echo "Error: PDS_VIP not found"; echo $OUTPUT; exit 1; }

PDS_PORT=$(echo $PDS_CONNECTION | jq -r '.clusterDetails.port')
[[ $PDS_PORT == "null" ]] && { echo "Error: PDS_PORT not found"; echo $OUTPUT; exit 1; }

echo "PDS Deployment Ready"
echo "Creating Petclinic Application"

sed -e "s/(NAMESPACE)/$PDS_NAMESPACE/g" -e "s/(VIP)/$PDS_VIP/g" -e "s/(PORT)/$PDS_PORT/g" -e "s/(CREDS)/$PDS_DEPLOYMENT_CLUSTER_RESOURCE_NAME-creds/g" /assets/pds-petclinic/pds-petclinic.tpl > /assets/pds-petclinic/pds-petclinic.yaml

kubectl apply -f /assets/pds-petclinic/pds-petclinic.yaml

